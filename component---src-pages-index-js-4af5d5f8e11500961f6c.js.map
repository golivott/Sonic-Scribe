{"version":3,"file":"component---src-pages-index-js-4af5d5f8e11500961f6c.js","mappings":"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","sources":["webpack://sonic-scribe/./src/components/StaffVisualizer.js","webpack://sonic-scribe/./src/noteSequenceToMusicXML.js","webpack://sonic-scribe/./node_modules/idb/build/wrap-idb-value.js","webpack://sonic-scribe/./node_modules/idb/build/index.js","webpack://sonic-scribe/./src/transcribe.js","webpack://sonic-scribe/./src/pages/index.js"],"sourcesContent":["import { quantizeNoteSequence } from \"@magenta/music/esm/core/sequences\";\r\nimport React from \"react\";\r\nimport { useEffect, useRef } from \"react\";\r\nimport * as mm from \"@magenta/music\";\r\n\r\nexport default function StaffVisualizer({ noteSequence }) {\r\n    const visualizerRef = useRef(null);\r\n\r\n    useEffect(() => {\r\n        if (noteSequence) {\r\n            let notes = noteSequence;\r\n            if (!notes.quantizationInfo) notes = quantizeNoteSequence(noteSequence, 4);\r\n\r\n            const visualizer = new mm.StaffSVGVisualizer(notes, visualizerRef.current);\r\n            visualizer.redraw();\r\n        }\r\n    }, [noteSequence]);\r\n\r\n    return <div ref={visualizerRef}></div>;\r\n}\r\n","import { quantizeNoteSequence } from \"@magenta/music/esm/core/sequences\";\r\nimport * as mm from \"@magenta/music/esm\";\r\n\r\nconst NOTE_TYPES = {\r\n    1: \"1024th\",\r\n    2: \"512th\",\r\n    4: \"256th\",\r\n    8: \"128th\",\r\n    16: \"64th\",\r\n    32: \"32th\",\r\n    64: \"16th\",\r\n    128: \"eighth\",\r\n    256: \"quarter\",\r\n    512: \"half\",\r\n    1024: \"whole\",\r\n    2048: \"breve\",\r\n    4096: \"long\",\r\n    8192: \"maxima\",\r\n};\r\n\r\nexport function noteSequenceToMusicXML(noteSequence) {\r\n    let notes = new mm.NoteSequence(noteSequence);\r\n    if (!notes.tempos[0].qpm) notes = quantizeNoteSequence(noteSequence);\r\n\r\n    const SMALLEST_NOTE_LENGTH_SECONDS = 60 / (notes.tempos[0].qpm * 256);\r\n\r\n    // Start of the XML document\r\n    let musicXML = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n\t<!DOCTYPE score-partwise PUBLIC\r\n\t\t\"-//Recordare//DTD MusicXML 4.0 Partwise//EN\"\r\n\t\t\"http://www.musicxml.org/dtds/partwise.dtd\">\r\n\t<score-partwise version=\"4.0\">\r\n\t  \t<part-list>\r\n\t\t\t<score-part id=\"P1\">\r\n\t\t  \t\t<part-name>Music</part-name>\r\n\t\t\t</score-part>\r\n\t  \t</part-list>\r\n\t  \t<part id=\"P1\">\r\n\t\t  \t`;\r\n\r\n    // Prep notes for MusicXML conversion\r\n    let fixedNotes = notes.notes.slice().map((note) => ({\r\n        pitch: note.pitch,\r\n        startTime: note.startTime,\r\n        endTime: note.endTime,\r\n        duration: Math.round((note.endTime - note.startTime) / SMALLEST_NOTE_LENGTH_SECONDS),\r\n        noteType: NOTE_TYPES[Math.round((note.endTime - note.startTime) / SMALLEST_NOTE_LENGTH_SECONDS)],\r\n        tied: null,\r\n    }));\r\n\r\n    fixedNotes.sort((a, b) => {\r\n        if (a.startTime === b.startTime) {\r\n            return a.endTime - b.endTime;\r\n        }\r\n        return a.startTime - b.startTime;\r\n    });\r\n\r\n    let newFixedNotes = [];\r\n    for (let i = 0; i < fixedNotes.length; i++) {\r\n        // This breaks down notes with bad durations so they can be tied\r\n        newFixedNotes.push(fixedNotes[i]);\r\n\r\n        // while this not does not have a note type\r\n        while (!newFixedNotes[newFixedNotes.length - 1].noteType) {\r\n            // find the biggest note type that will fit\r\n            //     newFixedNotes[i].tied = `<notations>\r\n            // \t<tied type=\"start\"/>\r\n            //  </notations>`;\r\n            for (let noteLength of Object.keys(NOTE_TYPES).sort((a, b) => b - a)) {\r\n                if (newFixedNotes[newFixedNotes.length - 1].duration > noteLength) {\r\n                    newFixedNotes[newFixedNotes.length - 1].noteType = NOTE_TYPES[noteLength]; // for now we are just using the closest note that will fit need to implement note tieing\r\n                    //             // Adding a new adjusted note\r\n                    //             let thisIndex = newFixedNotes.length - 1;\r\n                    //             let nextIndex = thisIndex + 1;\r\n                    //             newFixedNotes.push(newFixedNotes[thisIndex]);\r\n                    //             newFixedNotes[nextIndex].duration = newFixedNotes[thisIndex].duration - noteLength;\r\n                    //             newFixedNotes[nextIndex].startTime += noteLength * SMALLEST_NOTE_LENGTH_SECONDS;\r\n                    //             newFixedNotes[nextIndex].noteType = NOTE_TYPES[newFixedNotes[thisIndex].duration];\r\n                    //             newFixedNotes[nextIndex].tied = `<notations>\r\n                    // \t<tied type=\"let-ring\"/>\r\n                    //  </notations>`;\r\n\r\n                    //             // Fixing current note\r\n                    //             newFixedNotes[thisIndex].duration = noteLength;\r\n                    //             newFixedNotes[thisIndex].endTime -= noteLength * SMALLEST_NOTE_LENGTH_SECONDS;\r\n                    //             newFixedNotes[thisIndex].noteType = NOTE_TYPES[newFixedNotes[thisIndex].duration];\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //     if (newFixedNotes[newFixedNotes.length - 1].noteType) {\r\n            //         newFixedNotes[newFixedNotes.length - 1].tied = `<notations>\r\n            // \t\t<tied type=\"stop\"/>\r\n            //  </notations>`;\r\n            //     }\r\n        }\r\n    }\r\n\r\n    newFixedNotes.sort((a, b) => {\r\n        if (a.startTime === b.startTime) {\r\n            return a.endTime - b.endTime;\r\n        }\r\n        return a.startTime - b.startTime;\r\n    });\r\n\r\n    musicXML += `\r\n\t\t\t\t<measure number=\"1\">\r\n\t\t\t\t<attributes>\r\n\t\t\t\t\t<divisions>256</divisions>\r\n\t\t\t\t\t<key>\r\n\t\t\t\t\t  <fifths>0</fifths>\r\n\t\t\t\t\t</key>\r\n\t\t\t\t\t<time>\r\n\t\t\t\t\t  <beats>4</beats>\r\n\t\t\t\t\t  <beat-type>4</beat-type>\r\n\t\t\t\t\t</time>\r\n\t\t\t\t\t<staves>2</staves>\r\n\t\t\t\t  <clef number=\"1\">\r\n\t\t\t\t\t\t<sign>G</sign>\r\n\t\t\t\t\t\t<line>2</line>\r\n\t\t\t\t  </clef>\r\n\t\t\t\t  <clef number=\"2\">\r\n\t\t\t\t\t\t<sign>F</sign>\r\n\t\t\t\t\t\t<line>4</line>\r\n\t\t\t\t  </clef>\r\n\t\t\t  </attributes>`;\r\n\r\n    // Convert each note to MusicXML\r\n    let divisions = 0;\r\n    for (let [i, note] of newFixedNotes.entries()) {\r\n        // divisions += note.duration;\r\n        // if (divisions % (256 * 3) === 0) {\r\n        //     if (divisions % (256 * 3) === 0) {\r\n        //         musicXML += `\r\n        // \t\t</measure>`;\r\n        //     }\r\n\r\n        //     musicXML += `\r\n        // \t\t<measure number=\"${Math.floor(divisions / (256 * 3)) + 1}\">\r\n        // \t\t<print new-system=\"yes\"/>\r\n        // \t\t`;\r\n        // }\r\n\r\n        musicXML += `\r\n\t\t\t<note>\r\n\t\t\t\t${i > 0 ? (newFixedNotes[i - 1].startTime === note.startTime ? \"<chord />\" : \"\") : \"\"}\r\n\t\t\t\t<pitch>\r\n\t\t\t\t\t  <step>${getNote(note.pitch).step}</step>\r\n\t\t\t\t\t<alter>${getNote(note.pitch).alter}</alter>\r\n\t\t\t\t\t  <octave>${getNote(note.pitch).octave}</octave>\r\n\t\t\t\t</pitch>\r\n\t\t\t\t<duration>${note.duration}</duration>\r\n\t\t\t\t<type>${note.noteType}</type>\r\n\t\t\t\t${note.tied ? note.tied : \"\"}\r\n\t\t\t</note>\r\n\t\t\t`;\r\n    }\r\n\r\n    musicXML += `\r\n\t\t\t\t</measure>`;\r\n\r\n    // End of the XML document\r\n    musicXML += `\r\n\t\t</part>\r\n\t</score-partwise>`;\r\n\r\n    return musicXML;\r\n}\r\n\r\n// This only uses sharps and only works for C Major fix later\r\nfunction getNote(midiPitch) {\r\n    const notes = {\r\n        0: \"A\", // A\r\n        1: \"A\", // A#\r\n        2: \"B\", // B\r\n        3: \"C\", // C\r\n        4: \"C\", // C#\r\n        5: \"D\", // D\r\n        6: \"D\", // D#\r\n        7: \"E\", // E\r\n        8: \"F\", // F\r\n        9: \"F\", // F#\r\n        10: \"G\", // G\r\n        11: \"G\", // G#\r\n    };\r\n\r\n    const alters = {\r\n        0: 0, // A\r\n        1: 1, // A#\r\n        2: 0, // B\r\n        3: 0, // C\r\n        4: 1, // C#\r\n        5: 0, // D\r\n        6: 1, // D#\r\n        7: 0, // E\r\n        8: 0, // F\r\n        9: 1, // F#\r\n        10: 0, // G\r\n        11: 1, // G#\r\n    };\r\n\r\n    return {\r\n        step: notes[(midiPitch - 21) % 12],\r\n        alter: alters[(midiPitch - 21) % 12],\r\n        octave: Math.floor((midiPitch - 12) / 12),\r\n    };\r\n}\r\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { OnsetsAndFrames } from \"@magenta/music/esm/transcription\";\r\nimport { openDB } from \"idb\";\r\n\r\nlet model;\r\nlet modelReady = false; // Use this bool to check if the model is ready\r\n\r\n// Downloads model\r\nexport async function initOnsetsAndFrames() {\r\n    if (modelReady) return true; // If the model is loaded return true\r\n\r\n    // Create a storage location for this model\r\n    const db = await openDB(\"my-database\", 1, {\r\n        upgrade(db) {\r\n            db.createObjectStore(\"models\");\r\n        },\r\n    });\r\n\r\n    // Try to retrieve the model from the user cache\r\n    model = await db.get(\"models\", \"onsetsAndFrames\");\r\n\r\n    // If the user doesn't have the model download it\r\n    if (!model) {\r\n        console.log(\"Downloading Model ...\");\r\n        model = new OnsetsAndFrames(\r\n            \"https://storage.googleapis.com/magentadata/js/checkpoints/transcription/onsets_frames_uni\"\r\n        );\r\n\r\n        await model.initialize();\r\n        await db.put(\"models\", model, \"onsetsAndFrames\");\r\n    } else {\r\n        console.log(\"Found model in indexedDB!\");\r\n    }\r\n\r\n    modelReady = true;\r\n    return true;\r\n}\r\n\r\n// Transcribes audio file to a note sequence\r\nexport async function transcribeFromAudioFile(file) {\r\n    // Create a Blob from the file\r\n    const blob = await createBlob(file);\r\n\r\n    // Ensure the model is ready before transcribing\r\n    if (!modelReady) {\r\n        await initOnsetsAndFrames();\r\n    }\r\n\r\n    // Transcribe the audio file\r\n    const noteSequence = await model.transcribeFromAudioFile(blob);\r\n    console.log(noteSequence);\r\n\r\n    return noteSequence;\r\n}\r\n\r\n// Create a blob from the file\r\nfunction createBlob(file) {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n\r\n        reader.onload = (event) => {\r\n            const result = reader.result;\r\n            const blob = new Blob([result], { type: file.type });\r\n            resolve(blob);\r\n        };\r\n\r\n        reader.onerror = (event) => {\r\n            reject(reader.error);\r\n        };\r\n\r\n        reader.readAsArrayBuffer(file);\r\n    });\r\n}\r\n","import * as React from \"react\";\r\nimport { useState, useEffect } from \"react\";\r\nimport StaffVisualizer from \"../components/StaffVisualizer\";\r\nimport PianoRollVisualizer from \"../components/PianoRollVisualizer\";\r\nimport * as mm from \"@magenta/music\";\r\nimport { noteSequenceToMusicXML } from \"../noteSequenceToMusicXML\";\r\nimport UploadButtonComponent from \"../components/UploadButton\";\r\nimport { initOnsetsAndFrames, transcribeFromAudioFile } from \"../transcribe\";\r\n\r\nconst IndexPage = () => {\r\n    const [modelReady, setModelReady] = useState(false);\r\n    const [file, setFile] = useState(null);\r\n    const [noteSequence, setNoteSequence] = useState(null);\r\n\r\n    useEffect(() => {\r\n        const init = async () => {\r\n            try {\r\n                setModelReady(await initOnsetsAndFrames());\r\n            } catch (error) {\r\n                console.error(\"Error initializing model:\", error);\r\n            }\r\n        };\r\n\r\n        init();\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        if (file && modelReady) {\r\n            if (file.name.split(\".\")[1] === \"mid\" || file.name.split(\".\")[1] === \"midi\") {\r\n                function createArray(file) {\r\n                    return new Promise((resolve, reject) => {\r\n                        const reader = new FileReader();\r\n\r\n                        reader.onload = (event) => {\r\n                            const result = reader.result;\r\n                            resolve(result);\r\n                        };\r\n\r\n                        reader.onerror = (event) => {\r\n                            reject(reader.error);\r\n                        };\r\n\r\n                        reader.readAsArrayBuffer(file);\r\n                    });\r\n                }\r\n\r\n                const createNoteSequence = async () => {\r\n                    setNoteSequence(mm.midiToSequenceProto(await createArray(file)));\r\n                };\r\n\r\n                createNoteSequence();\r\n            } else {\r\n                // const transcribe = async () => {\r\n                //     try {\r\n                //         let output = await transcribeFromAudioFile(file);\r\n                //         setNoteSequence(output);\r\n                //     } catch (error) {\r\n                //         console.error(\"Error transcribing file:\", error);\r\n                //     }\r\n                // };\r\n                // transcribe();\r\n            }\r\n        }\r\n    }, [file, modelReady]);\r\n\r\n    function downloadFile(data, filename, type) {\r\n        const blob = new Blob([data], { type });\r\n        const url = URL.createObjectURL(blob);\r\n        const link = document.createElement(\"a\");\r\n        link.href = url;\r\n        link.download = filename;\r\n        document.body.appendChild(link);\r\n        link.click();\r\n        document.body.removeChild(link);\r\n    }\r\n\r\n    return (\r\n        <>\r\n            {modelReady ? (\r\n                <>\r\n                    <UploadButtonComponent onFileUpload={setFile}></UploadButtonComponent>\r\n                    {file &&\r\n                        (noteSequence ? (\r\n                            <>\r\n                                <PianoRollVisualizer noteSequence={noteSequence}></PianoRollVisualizer>\r\n                                <StaffVisualizer noteSequence={noteSequence}></StaffVisualizer>\r\n                            </>\r\n                        ) : (\r\n                            <p>Transcribing ...</p>\r\n                        ))}\r\n                </>\r\n            ) : (\r\n                <p>Loading Model...</p>\r\n            )}\r\n\r\n            <button\r\n                onClick={() => {\r\n                    const musicXML = noteSequenceToMusicXML(noteSequence);\r\n                    downloadFile(musicXML, \"music.xml\", \"application/octet-stream\");\r\n                }}\r\n            >\r\n                Download MusicXML\r\n            </button>\r\n\r\n            <button\r\n                onClick={() => {\r\n                    const midiData = mm.sequenceProtoToMidi(noteSequence);\r\n                    downloadFile(midiData, \"music.midi\", \"application/octet-stream\");\r\n                }}\r\n            >\r\n                Download MIDI\r\n            </button>\r\n        </>\r\n    );\r\n};\r\n\r\nexport default IndexPage;\r\n\r\nexport const Head = () => <title>Home Page</title>;\r\n"],"names":["StaffVisualizer","noteSequence","visualizerRef","useRef","useEffect","notes","quantizationInfo","quantizeNoteSequence","mm","current","redraw","ref","NOTE_TYPES","getNote","midiPitch","step","alter","octave","Math","floor","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","get","target","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","set","value","has","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","this","storeNames","tx","call","sort","transformCachableValue","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","IDBRequest","request","promise","success","result","then","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","all","model","oldTraps","callback","modelReady","initOnsetsAndFrames","db","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","openDB","createObjectStore","console","log","OnsetsAndFrames","initialize","put","setModelReady","useState","file","setFile","setNoteSequence","downloadFile","data","filename","type","blob","Blob","url","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","init","split","createArray","reader","FileReader","onload","onerror","readAsArrayBuffer","createNoteSequence","UploadButton","onFileUpload","PianoRollVisualizer","onClick","musicXML","tempos","qpm","SMALLEST_NOTE_LENGTH_SECONDS","fixedNotes","slice","map","note","pitch","startTime","endTime","duration","round","noteType","tied","a","b","newFixedNotes","i","length","push","noteLength","Object","keys","entries","noteSequenceToMusicXML","Head"],"sourceRoot":""}