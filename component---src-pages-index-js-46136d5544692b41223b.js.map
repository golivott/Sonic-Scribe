{"version":3,"file":"component---src-pages-index-js-46136d5544692b41223b.js","mappings":"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","sources":["webpack://sonic-scribe/./src/components/StaffVisualizer.js","webpack://sonic-scribe/./src/noteSequenceToMusicXML.js","webpack://sonic-scribe/./src/transcribe.js","webpack://sonic-scribe/./src/pages/index.js"],"sourcesContent":["import { quantizeNoteSequence } from \"@magenta/music/esm/core/sequences\";\nimport React from \"react\";\nimport { useEffect, useRef } from \"react\";\nimport * as mm from \"@magenta/music\";\n\nexport default function StaffVisualizer({ noteSequence }) {\n    const visualizerRef = useRef(null);\n\n    useEffect(() => {\n        if (noteSequence) {\n            let notes = noteSequence;\n            if (!notes.quantizationInfo) notes = quantizeNoteSequence(noteSequence, 4);\n\n            const visualizer = new mm.StaffSVGVisualizer(notes, visualizerRef.current);\n            visualizer.redraw();\n        }\n    }, [noteSequence]);\n\n    return <div ref={visualizerRef}></div>;\n}\n","import { quantizeNoteSequence } from \"@magenta/music/esm/core/sequences\";\nimport * as mm from \"@magenta/music/esm\";\n\nconst NOTE_TYPES = {\n    1: \"1024th\",\n    2: \"512th\",\n    4: \"256th\",\n    8: \"128th\",\n    16: \"64th\",\n    32: \"32th\",\n    64: \"16th\",\n    128: \"eighth\",\n    256: \"quarter\",\n    512: \"half\",\n    1024: \"whole\",\n    2048: \"breve\",\n    4096: \"long\",\n    8192: \"maxima\",\n};\n\nexport function noteSequenceToMusicXML(noteSequence) {\n    let notes = new mm.NoteSequence(noteSequence);\n    if (!notes.tempos[0].qpm) notes = quantizeNoteSequence(noteSequence);\n\n    const SMALLEST_NOTE_LENGTH_SECONDS = 60 / (notes.tempos[0].qpm * 256);\n\n    // Start of the XML document\n    let musicXML = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n\t<!DOCTYPE score-partwise PUBLIC\n\t\t\"-//Recordare//DTD MusicXML 4.0 Partwise//EN\"\n\t\t\"http://www.musicxml.org/dtds/partwise.dtd\">\n\t<score-partwise version=\"4.0\">\n\t  \t<part-list>\n\t\t\t<score-part id=\"P1\">\n\t\t  \t\t<part-name>Music</part-name>\n\t\t\t</score-part>\n\t  \t</part-list>\n\t  \t<part id=\"P1\">\n\t\t  \t`;\n\n    // Prep notes for MusicXML conversion\n    let fixedNotes = notes.notes.slice().map((note) => ({\n        pitch: note.pitch,\n        startTime: note.startTime,\n        endTime: note.endTime,\n        duration: Math.round((note.endTime - note.startTime) / SMALLEST_NOTE_LENGTH_SECONDS),\n        noteType: NOTE_TYPES[Math.round((note.endTime - note.startTime) / SMALLEST_NOTE_LENGTH_SECONDS)],\n        tied: null,\n    }));\n\n    fixedNotes.sort((a, b) => {\n        if (a.startTime === b.startTime) {\n            return a.endTime - b.endTime;\n        }\n        return a.startTime - b.startTime;\n    });\n\n    let newFixedNotes = [];\n    for (let i = 0; i < fixedNotes.length; i++) {\n        // This breaks down notes with bad durations so they can be tied\n        newFixedNotes.push(fixedNotes[i]);\n\n        // while this not does not have a note type\n        while (!newFixedNotes[newFixedNotes.length - 1].noteType) {\n            // find the biggest note type that will fit\n            //     newFixedNotes[i].tied = `<notations>\n            // \t<tied type=\"start\"/>\n            //  </notations>`;\n            for (let noteLength of Object.keys(NOTE_TYPES).sort((a, b) => b - a)) {\n                if (newFixedNotes[newFixedNotes.length - 1].duration > noteLength) {\n                    newFixedNotes[newFixedNotes.length - 1].noteType = NOTE_TYPES[noteLength]; // for now we are just using the closest note that will fit need to implement note tieing\n                    //             // Adding a new adjusted note\n                    //             let thisIndex = newFixedNotes.length - 1;\n                    //             let nextIndex = thisIndex + 1;\n                    //             newFixedNotes.push(newFixedNotes[thisIndex]);\n                    //             newFixedNotes[nextIndex].duration = newFixedNotes[thisIndex].duration - noteLength;\n                    //             newFixedNotes[nextIndex].startTime += noteLength * SMALLEST_NOTE_LENGTH_SECONDS;\n                    //             newFixedNotes[nextIndex].noteType = NOTE_TYPES[newFixedNotes[thisIndex].duration];\n                    //             newFixedNotes[nextIndex].tied = `<notations>\n                    // \t<tied type=\"let-ring\"/>\n                    //  </notations>`;\n\n                    //             // Fixing current note\n                    //             newFixedNotes[thisIndex].duration = noteLength;\n                    //             newFixedNotes[thisIndex].endTime -= noteLength * SMALLEST_NOTE_LENGTH_SECONDS;\n                    //             newFixedNotes[thisIndex].noteType = NOTE_TYPES[newFixedNotes[thisIndex].duration];\n\n                    break;\n                }\n            }\n\n            //     if (newFixedNotes[newFixedNotes.length - 1].noteType) {\n            //         newFixedNotes[newFixedNotes.length - 1].tied = `<notations>\n            // \t\t<tied type=\"stop\"/>\n            //  </notations>`;\n            //     }\n        }\n    }\n\n    newFixedNotes.sort((a, b) => {\n        if (a.startTime === b.startTime) {\n            return a.endTime - b.endTime;\n        }\n        return a.startTime - b.startTime;\n    });\n\n    musicXML += `\n\t\t\t\t<measure number=\"1\">\n\t\t\t\t<attributes>\n\t\t\t\t\t<divisions>256</divisions>\n\t\t\t\t\t<key>\n\t\t\t\t\t  <fifths>0</fifths>\n\t\t\t\t\t</key>\n\t\t\t\t\t<time>\n\t\t\t\t\t  <beats>4</beats>\n\t\t\t\t\t  <beat-type>4</beat-type>\n\t\t\t\t\t</time>\n\t\t\t\t\t<staves>2</staves>\n\t\t\t\t  <clef number=\"1\">\n\t\t\t\t\t\t<sign>G</sign>\n\t\t\t\t\t\t<line>2</line>\n\t\t\t\t  </clef>\n\t\t\t\t  <clef number=\"2\">\n\t\t\t\t\t\t<sign>F</sign>\n\t\t\t\t\t\t<line>4</line>\n\t\t\t\t  </clef>\n\t\t\t  </attributes>`;\n\n    // Convert each note to MusicXML\n    let divisions = 0;\n    for (let [i, note] of newFixedNotes.entries()) {\n        // divisions += note.duration;\n        // if (divisions % (256 * 3) === 0) {\n        //     if (divisions % (256 * 3) === 0) {\n        //         musicXML += `\n        // \t\t</measure>`;\n        //     }\n\n        //     musicXML += `\n        // \t\t<measure number=\"${Math.floor(divisions / (256 * 3)) + 1}\">\n        // \t\t<print new-system=\"yes\"/>\n        // \t\t`;\n        // }\n\n        musicXML += `\n\t\t\t<note>\n\t\t\t\t${i > 0 ? (newFixedNotes[i - 1].startTime === note.startTime ? \"<chord />\" : \"\") : \"\"}\n\t\t\t\t<pitch>\n\t\t\t\t\t  <step>${getNote(note.pitch).step}</step>\n\t\t\t\t\t<alter>${getNote(note.pitch).alter}</alter>\n\t\t\t\t\t  <octave>${getNote(note.pitch).octave}</octave>\n\t\t\t\t</pitch>\n\t\t\t\t<duration>${note.duration}</duration>\n\t\t\t\t<type>${note.noteType}</type>\n\t\t\t\t${note.tied ? note.tied : \"\"}\n\t\t\t</note>\n\t\t\t`;\n    }\n\n    musicXML += `\n\t\t\t\t</measure>`;\n\n    // End of the XML document\n    musicXML += `\n\t\t</part>\n\t</score-partwise>`;\n\n    return musicXML;\n}\n\n// This only uses sharps and only works for C Major fix later\nfunction getNote(midiPitch) {\n    const notes = {\n        0: \"A\", // A\n        1: \"A\", // A#\n        2: \"B\", // B\n        3: \"C\", // C\n        4: \"C\", // C#\n        5: \"D\", // D\n        6: \"D\", // D#\n        7: \"E\", // E\n        8: \"F\", // F\n        9: \"F\", // F#\n        10: \"G\", // G\n        11: \"G\", // G#\n    };\n\n    const alters = {\n        0: 0, // A\n        1: 1, // A#\n        2: 0, // B\n        3: 0, // C\n        4: 1, // C#\n        5: 0, // D\n        6: 1, // D#\n        7: 0, // E\n        8: 0, // F\n        9: 1, // F#\n        10: 0, // G\n        11: 1, // G#\n    };\n\n    return {\n        step: notes[(midiPitch - 21) % 12],\n        alter: alters[(midiPitch - 21) % 12],\n        octave: Math.floor((midiPitch - 12) / 12),\n    };\n}\n","import { OnsetsAndFrames } from \"@magenta/music/esm/transcription\";\r\n\r\nlet model;\r\nlet modelReady = false; // Use this bool to check if the model is ready\r\n\r\n// Downloads model\r\nexport async function initOnsetsAndFrames() {\r\n    if (modelReady) return true; // If the model is loaded return true\r\n\r\n    console.log(\"Downloading Model ...\");\r\n    model = new OnsetsAndFrames(\r\n        \"https://storage.googleapis.com/magentadata/js/checkpoints/transcription/onsets_frames_uni\"\r\n    );\r\n\r\n    await model.initialize();\r\n\r\n    modelReady = true;\r\n    return true;\r\n}\r\n\r\n// Transcribes audio file to a note sequence\r\nexport async function transcribeFromAudioFile(file) {\r\n    // Create a Blob from the file\r\n    const blob = await createBlob(file);\r\n\r\n    // Ensure the model is ready before transcribing\r\n    if (!modelReady) {\r\n        await initOnsetsAndFrames();\r\n    }\r\n\r\n    // Transcribe the audio file\r\n    const noteSequence = await model.transcribeFromAudioFile(blob);\r\n    console.log(noteSequence);\r\n\r\n    return noteSequence;\r\n}\r\n\r\n// Create a blob from the file\r\nfunction createBlob(file) {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n\r\n        reader.onload = (event) => {\r\n            const result = reader.result;\r\n            const blob = new Blob([result], { type: file.type });\r\n            resolve(blob);\r\n        };\r\n\r\n        reader.onerror = (event) => {\r\n            reject(reader.error);\r\n        };\r\n\r\n        reader.readAsArrayBuffer(file);\r\n    });\r\n}\r\n","import * as React from \"react\";\nimport { useState, useEffect } from \"react\";\nimport StaffVisualizer from \"../components/StaffVisualizer\";\nimport PianoRollVisualizer from \"../components/PianoRollVisualizer\";\nimport * as mm from \"@magenta/music\";\nimport { noteSequenceToMusicXML } from \"../noteSequenceToMusicXML\";\nimport UploadButtonComponent from \"../components/UploadButton\";\nimport { initOnsetsAndFrames, transcribeFromAudioFile } from \"../transcribe\";\n\nconst IndexPage = () => {\n    const [modelReady, setModelReady] = useState(false);\n    const [file, setFile] = useState(null);\n    const [noteSequence, setNoteSequence] = useState(null);\n\n    useEffect(() => {\n        const init = async () => {\n            try {\n                setModelReady(await initOnsetsAndFrames());\n            } catch (error) {\n                console.error(\"Error initializing model:\", error);\n            }\n        };\n\n        init();\n    }, []);\n\n    useEffect(() => {\n        if (file && modelReady) {\n            if (file.name.split(\".\")[1] === \"mid\" || file.name.split(\".\")[1] === \"midi\") {\n                function createArray(file) {\n                    return new Promise((resolve, reject) => {\n                        const reader = new FileReader();\n\n                        reader.onload = (event) => {\n                            const result = reader.result;\n                            resolve(result);\n                        };\n\n                        reader.onerror = (event) => {\n                            reject(reader.error);\n                        };\n\n                        reader.readAsArrayBuffer(file);\n                    });\n                }\n\n                const createNoteSequence = async () => {\n                    setNoteSequence(mm.midiToSequenceProto(await createArray(file)));\n                };\n\n                createNoteSequence();\n            } else {\n                const transcribe = async () => {\n                    try {\n                        let output = await transcribeFromAudioFile(file);\n                        setNoteSequence(output);\n                    } catch (error) {\n                        console.error(\"Error transcribing file:\", error);\n                    }\n                };\n\n                transcribe();\n            }\n        }\n    }, [file, modelReady]);\n\n    function downloadFile(data, filename, type) {\n        const blob = new Blob([data], { type });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement(\"a\");\n        link.href = url;\n        link.download = filename;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n\n    return (\n        <>\n            {modelReady ? (\n                <>\n                    <UploadButtonComponent onFileUpload={setFile}></UploadButtonComponent>\n                    {file &&\n                        (noteSequence ? (\n                            <>\n                                <PianoRollVisualizer noteSequence={noteSequence}></PianoRollVisualizer>\n                                <StaffVisualizer noteSequence={noteSequence}></StaffVisualizer>\n                            </>\n                        ) : (\n                            <p>Transcribing ...</p>\n                        ))}\n                </>\n            ) : (\n                <p>Loading Model...</p>\n            )}\n\n            <button\n                onClick={() => {\n                    const musicXML = noteSequenceToMusicXML(noteSequence);\n                    downloadFile(musicXML, \"music.xml\", \"application/octet-stream\");\n                }}\n            >\n                Download MusicXML\n            </button>\n\n            <button\n                onClick={() => {\n                    const midiData = mm.sequenceProtoToMidi(noteSequence);\n                    downloadFile(midiData, \"music.midi\", \"application/octet-stream\");\n                }}\n            >\n                Download MIDI\n            </button>\n        </>\n    );\n};\n\nexport default IndexPage;\n\nexport const Head = () => <title>Test Page</title>;\n"],"names":["StaffVisualizer","noteSequence","visualizerRef","useRef","useEffect","notes","quantizationInfo","quantizeNoteSequence","mm","current","redraw","ref","NOTE_TYPES","getNote","midiPitch","step","alter","octave","Math","floor","model","modelReady","async","initOnsetsAndFrames","console","log","OnsetsAndFrames","initialize","transcribeFromAudioFile","file","blob","Promise","resolve","reject","reader","FileReader","onload","event","result","Blob","type","onerror","error","readAsArrayBuffer","createBlob","setModelReady","useState","setFile","setNoteSequence","downloadFile","data","filename","url","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","init","name","split","createArray","createNoteSequence","output","transcribe","UploadButton","onFileUpload","PianoRollVisualizer","onClick","musicXML","tempos","qpm","SMALLEST_NOTE_LENGTH_SECONDS","fixedNotes","slice","map","note","pitch","startTime","endTime","duration","round","noteType","tied","sort","a","b","newFixedNotes","i","length","push","noteLength","Object","keys","entries","noteSequenceToMusicXML","Head"],"sourceRoot":""}